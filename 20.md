# 思考题

## 信号的基本特性

### 总结提到信号可以由内核、另一进程或进程自身发送给进程

#### 请为每种来源举一个实际例子

##### 内核发送信号的场景（至少2个例子）

- SIGSEGV（段错误）：当进程访问非法内存地址时，由内存管理单元触发，内核发送此信号
- STGALRM（定时器信号）：当通过 alarm()或setitimer()设置的定时器到期时，内核发送此信号

##### 另一进程发送信号的场景

- kill命令：用户通过shell发送信号给进程
- 进程间通信：一个进程监控另一个进程，在特定条件下发送信号

##### 进程自身发送信号的场景

- raise(sig)
- abort()：发送 SIGABRT 给自己，通常用于异常终止

#### 为什么信号传递通常是异步的？什么时候会是同步的？

- 异步信号：信号的产生和进程的当前执行点没有必然联系。进程无法预测何时会收到信号
- 同步信号：有进程自身的执行直接触发，可预测可重现

## 信号的默认行为与自定义处理

### 总结提到信号的默认行为和自定义处理方式

#### 信号 SIGINT（Ctrl+C）和 SIGSEGV（段错误）的默认行为分别是什么？有什么区别？

SIGINT默认行为不产生核心转储文件，SIGSEGV默认行为产生核心转储文件

#### 为什么总结建议使用 sigaction() 而不是 signal() 来建立信号处理器？

具有可移植性

## 信号的阻塞与等待

### 总结提到信号掩码、阻塞和等待状态

#### 什么是信号掩码？

每个进程都有一个信息掩码，它定义了当前被阻塞的信号集合。

#### 假设进程阻塞了 SIGUSR1 信号，在此期间收到了3次 SIGUSR1。解除阻塞后，进程会收到几次 SIGUSR1？为什么？

收到一次。标准信号不排队

## 信号的发送与检测

### 总结提到 kill() 函数和空信号的用途

#### kill(pid, 0) 的作用是什么？它的返回值能告诉你什么信息？

kill(pid, 0)检查进程是否存在和权限
