# 总结

## `wait()`族系统调用

这是父进程同步和回收子进程的主要工具。

1.主要函数：

  `pid_t wait(int *status);`

   `pid_t waitpid(pid_t pid, int *status, int options);`

2.核心作用:

- 获取子进程终止状态：通过 status 参数返回，可以使用一系列宏来解析子进程是如何终止的（正常退出/被信号杀死/被信号停止/恢复执行）

- 释放系统资源：防止子进程变成“僵尸进程”

3.`wait()` vs `waitpid()`：

- `wait(&status)`：阻塞等待任意一个子进程终止
- `waitpid(pid, &status, options)`：提供了精确控制

## 僵尸进程

一个已经终止，但其退出状态尚未被父进程通过 `wait()`读取的进程。

1. 危害：僵尸进程不占用内存或CPU，但它占用一个内核进程表项。如果大量产生且不被回收，会导致系统无法创建新进程。
2. 产生：子进程终止了，但父进程没有调用 `wait()`。
3. 删除：

- 父进程调用 `wait()`或 `waitpid()`回收。
- 父进程将 `SIGCHLD`信号的处理方式设置为 `SIG_IGN`，内核会自动清理其终止的子进程，不产生僵尸进程
- 杀死父进程。僵尸子进程会被` init `进程接管并回收。

## 孤儿进程

父进程先于子进程终止，子进程就变成了孤儿进程。

- 内核会将孤儿进程的父进程ID重新设置为 1
- `init`作为所有孤儿进程的“养父”，`init`进程会周期性地调用 `wait()`来回收它们，防止它们最终成为僵尸进程

## SIGCHLD 信号

当子进程的状态改变时，内核会向其父进程发送 SIGCHLD 信号。

- 父进程为 SIGCHLD 信号安装一个信号处理函数。在该处理函数内部，通常使用 `waitpid(-1, &status, WNOHANG)`在一个循环中回收所有已经终止的子进程。

- WNOHANG 确保在处理函数中，如果没有已终止的子进程，`waitpid`会立即返回而不阻塞，防止信号处理函数挂起。

- 循环调用 `waitpid`：因为多个子进程终止只发送一次 SIGCHLD，所以需要循环回收，直到 waitpid 返回0或-1
