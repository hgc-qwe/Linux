# 思考题

## “系统调用”与“库函数”的界限

### 书中提到，printf() 是库函数，它会调用系统调用 write() 来真正输出。那么，fwrite() 这个标准I/O库函数呢？你认为它在内部可能会如何利用系统调用来工作？在什么情况下它可能不会立即触发 write() 系统调用？（这涉及“用户空间缓冲区”的概念）

fwrite()是一个标准I/O库函数，他操作的是FILE*流对象。这个流对象内部维护着一个用户缓冲区。
如何利用系统调用：fwrite()通常会将数据先写入他内部的用户空间缓存区，当缓冲区被填满、或对流执行了fflush()、或者关闭文件流时，才会将缓冲区的数据通过一次write()系统调用写入内核缓冲区。
如何不触发：缓冲区未满；文件以行缓冲模式打开，且写入的数据不包含换行符；程序没有显示调用fflush()或fclose()

## 错误处理的本质

### 几乎所有系统调用和许多库函数在出错时都会返回 -1 或 NULL，并设置全局变量 errno。书中强调：在调用可能失败的函数后，必须立即检查返回值

#### 为什么这是一个必须严格遵守的“铁律”？

程序的后续逻辑严重依赖于前一个操作的成功与否。如果不检查，程序会错误地假设操作成功，并继续执行，导致后续代码在错误的数据或状态上运行，引发不可预知的行为。

#### 如果不立即检查，随后再调用一个其他函数（比如 perror() 之前不小心调用了 printf()，可能会导致什么问题？（提示：想想 errno 的线程安全性在早期是如何实现的）

在早期，errno被定义为一个全局整形变量。他并不是线程安全的。如果在检查errno之前，调用了一个可能失败的函数，那么原始的errno值就会被覆盖，导致打印出完全错误的错误信息。
如今，errno 通常被实现为线程局部存储，每个线程有自己的 errno 副本，避免了线程间干扰，但函数间调用的覆盖风险依然存在。因此，立即检查返回值并保存或处理错误的习惯至关重要。

## 从用户态到内核态的切换

### 书中解释了系统调用会导致处理器从“用户态”切换到“内核态”

#### 用你自己的话描述一下，为什么操作系统需要设计这两种不同的运行模式？

为了在硬件层面提供保护，实现操作系统的稳定性和安全性。内核态是操作系统的核心代码运行的特权模式，可以执行所有机器指令。用户态是应用程序运行的受限模式，不能执行特权指令。

#### 如果应用程序代码能直接以内核态运行（比如直接读写硬盘任意扇区），会带来什么灾难性后果？

可能会破坏系统、破坏隔离性、导致系统崩溃。

## 命令

### cd 路径---更改目录

### pwd 显示当前所在目录的完整路径

### mkdir [-p] 路径---创建文件夹

### touch 路径---创建文件

### cat 路径---查看文件内容

### more 路径---查看文件内容（空格翻页，q退出）

### cp [-r] 文件或文件夹 要复制的位置---复制文件或文件夹

### mv 文件或文件夹 移动的位置---移动文件或文件夹（或改名）

### rm [-r -f] 文件---删除文件或文件夹

### which 要查找的命令---查看命令的程序文件存放在哪里

### find 起始路径 -name “文件名”---查找文件

### find 起始路径 -size +/-n(kMG)---查找文件
