# 总结

## `exec()`的基本行为

1.作用：将当前进程的代码段、数据段、堆和栈完全替换为一个新程序的映像。然后从新程序的`main()`函数开始执行
2.“替换”而非“创建”

- 进程的`PID`保持不变
- 许多进程属性被保留
- 被替换掉的是进程的内存映像

3.调用成功则不返回，只有调用失败时，才会返回-1并设置`errno`

## `exec()`函数家族

```c
int execl (const char *path, const char *arg, ... /*, (char *) NULL */);
int execv (const char *path, char *const argv[]);
int execle(const char *path, const char *arg, ... /*, (char *) NULL, char *const envp[] */);
int execve(const char *path, char *const argv[], char *const envp[]);
int execlp(const char *file, const char *arg, ... /*, (char *) NULL */);
int execvp(const char *file, char *const argv[]);
```

选择：

- 如果参数是固定的，用`execl()`或`execlp()`
- 如果参数是动态构建的数组，用`execv()`或`execvp()`
- 如果需要改变子进程的环境变量，必须使用带`e`的版本，`execle()`或`execve()`
- 如果要执行一个可能在任何`PATH`目录下的命令（如`ls`，`grep`），使用带`p`的版本，`execlp()`或`execvp()`

## `system()`函数

1.作用：在一个单独的进程中执行一个 shell 命令字符串，，并等待命令完成，返回其退出状态
2.实现：

- 创建子进程
- 在子进程中：`execl("/bin/sh", "sh", "-c", command, (char *) NULL);`
- 在父进程中：`waitpid(pid, &status, 0);`
- 返回处理后的`status`
- 注意对信号的处理
