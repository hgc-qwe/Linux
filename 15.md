# 思考题

## 文件权限的微妙之处

### 总结提到了3类用户（属主、属组、其他）和3种权限（读、写、执行）

#### 目录的执行权限有什么特殊含义？如果一个用户对某个目录有读权限但没有执行权限，他能列出该目录下的文件名吗？为什么？

表示能否进入该目录并访问其中的文件。不能列出目录内容，因为无法进入该目录

#### 用户A有一个文件，权限是 rw-rw-rw-（0666）。但用户B（与A同组）却无法修改这个文件。可能的原因是什么？（提示：考虑目录权限）

用户B可能没有目录的写权限，所以无法修改文件

## 特殊权限位的作用机制

### 总结提到了set-user-ID（SUID）、set-group-ID（SGID）和sticky位

#### SUID位：普通用户执行 /usr/bin/passwd 时，为什么能修改 /etc/shadow 文件（该文件通常只有root可写）？SUID位是如何改变进程权限的？

在设置了SGID的目录中创建文件时，文件的组所有权继承目录的组，而不是创建进程的有效组

#### Sticky位：对目录设置sticky位（如 /tmp）后，用户A不能删除用户B在该目录下的文件，这是如何实现的？

验证：

- 用户是root  允许
- 用户是目录属主  允许
- 用户是文件属主  允许
- 否则  不允许

## 时间戳与所有权操作

### 总结提到了文件时间戳和所有权修改

#### utime() 系统调用通常只能由文件属主或特权进程调用。但有一个例外情况：即使进程不是文件属主，只要对文件有写权限，也可以将文件的atime和mtime更新为当前时间。为什么这样设计是合理的？

合理。写操作会改变文件的修改时间，允许写操作的进程更新时间戳是一致的

#### 普通用户能使用 chown() 把自己拥有的文件转让给其他用户吗？为什么会有这个限制？

不能。防止用户滥用磁盘配额和权限系统。否则会是用户A用光自己的磁盘配额，将大文件转让给用户B，用户B的配额被占用

## umask的实践影响

### 总结提到umask是创建文件时的权限位掩码

#### 如果程序调用 open("file", O_CREAT, 0777)，而进程的umask是0022，文件的实际权限是什么？

0777 & ~0022 = 0755
rwxrwxrwx  ->  rwxr-xr-x

#### shell中执行 umask 077 和程序中调用 umask(077) 有什么区别？哪个影响范围更大？

shell执行会影响该shell及其所有子进程。程序执行会影响当前进程及其子进程
