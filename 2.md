# 思考题

## 内核与系统调用

==从应用程序的角度看，调用write()函数来向文件写入数据。请描述这个请求从用户空间到内核空间，再返回用户空间的完整旅程。关键步骤是什么？==
用户空间调度，参数准备，执行陷阱，内核路由，内核执行，返回用户空间，包装函数返回。
==为什么说系统调用是“受保护的”、“开销较大”的操作？==
受保护：系统调用是用户程序与内核交互的唯一合法入口。通过软中断和特权级切换，内核验证所有请求。
开销大：相较于普通函数调用，系统调用需要执行两次模式切换（用户态-->内核态-->用户态）、保存和恢复大量的CPU上下文、进行安全检查。

## 错误处理

==在Linux系统编程中，为什么永远不要忽略一个系统调用的返回值？请举例说明。==
系统调用随时可能失败，失败原因多样，忽略返回值会导致程序在错误状态下继续运行。
==当一个系统调用失败时，它如何告知程序具体的错误原因？程序又应该如何获取并处理这个原因？请写出标准的错误检查代码片段。==
系统通过返回值告知状态
内核在失败时，会设置一个全局整数变量 errno 来指示具体错误信息

```c
DIR* dir = opendir(path);
if (fd == -1) { 
    perror("opendir");
    exit(EXIT_FAILURE);
}
```

==errno变量是什么？它是一个普通的全局变量吗？在多线程环境下直接使用extern int errno;安全吗？为什么？==
errno是一个线程安全的整数变量
不安全。errno成为一个宏，每个线程都有自己的errno副本，应该始终包含<errno.h>头文件，使用它定义的errno。

## 可移植性

==书中提到了“标准”的重要性（如POSIX、SUS）。如果你想编写一个既能在Linux上运行，又能在FreeBSD或macOS上运行的程序，你应该主要依赖什么标准？为什么？==
依赖POSIX.1标准。它是IEEE制定的一套操作系统API标准，Linux、BSD、macOS、Solaris等都不同程度地遵循它。使用POSIX定义的函数和头文件，能最大程度保证代码在这些UNIX-like系统上源码级可移植。
==什么是特性测试宏（Feature Test Macro）？例如，_POSIX_C_SOURCE和_GNU_SOURCE的作用分别是什么？你在编译程序时如何定义它们？==
是编译时传递给编译器的宏定义，拥有与告诉C库希望启用哪些标准或扩展的特性。
_POSIX_C_SOURCE：当定义为 200809L 时，表示希望遵循POSIX.1-2008标准。C库只会暴露该标准及其之前定义的接口，隐藏掉非标准的或更新的接口。
_GNU_SOURCE：定义它意味着希望使用GNU C库的所有特性，包括GNU扩展、BSD函数、POSIX接口等。它会自动定义 _POSIX_C_SOURCE 等一系列宏。

## 基本库与内核

==C标准库（如glibc）和Linux内核之间是什么关系？printf()函数最终是如何将字符显示在终端上的？请指出其与系统调用write()的联系。==
C标准库是用户空间程序与内核之间的“中间层“。它提供了更易用更可移植的API，其底层最终会通过系统调用来请求内核服务。

- printf() 在C库内部根据格式字符串处理参数，将结果字符串存入一个用户空间的缓冲区。
- 当缓冲区满、遇到换行符、或程序主动调用 fflush() 时，C库会调用底层的 write() 系统调用。
- write() 系统调用将缓冲区的数据写入到文件描述符为 1 的对象中，这个文件描述符在程序启动时默认被绑定到标准输出，通常是终端。
- 内核接管 write() 调用，将数据最终送到终端驱动，驱动再控制显示器显示出来。
