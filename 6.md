# 思考题

## 进程环境列表的作用

### 总结提到每个进程会继承父进程的环境列表副本

#### 环境变量（如 PATH、HOME）在程序执行中起什么实际作用？请举例说明

配置程序行为、传递信息、运行时控制

#### 如果父进程设置了一个环境变量 MY_VAR=hello，然后 fork() 创建子进程，子进程修改了 MY_VAR 的值，这个修改会影响到父进程的环境变量吗？为什么？

不会。环境变量是通过fork()复制到子进程的副本。父进程的环境变量与子进程的环境变量不是一个副本

## 栈帧与函数调用

### 总结描述了栈帧包含局部变量、参数和调用链接信息

#### 用你自己的话解释，当函数A调用函数B，然后函数B又调用函数C时，栈上会如何排列这三个函数的栈帧？

- main()的栈帧  | 高地址
- A()的栈帧     |
- B()的栈帧     |
- C()的栈帧     V 低地址

#### 为什么栈帧的这种设计使得递归函数调用是可能的，但又有深度限制？

- 每个递归都有自己的栈帧，储存本次调用的局部变量和返回地址。这些栈帧互不干扰。
- 栈的空间有限，每次递归都会消耗栈

## 命令行参数传递

### 总结提到环境变量

#### getenv() 函数返回的字符串可以直接修改吗？为什么？

不可以。环境变量通常存储在进程内存的只读段或紧凑结构中，如果修改则可能影响其他变量

## 非局部跳转的隐患

### 总结强调应尽量避免使用 setjmp()/longjmp()

#### 假设函数A中调用 setjmp()，然后调用函数B，函数B又调用函数C，函数C中调用 longjmp() 跳回函数A。这会导致什么问题？（提示：考虑资源清理）

- 函数B和C的栈帧被跳过，没有正常返回
- 如果B或C打开了文件，文件描述符可能没有关闭。如果B或C调用malloc，内存泄漏。

### 为什么 volatile 修饰符在这种情况下很重要？如果不使用会发生什么？

volatile告诉编译器不要优化，可以确保变量储存的数据不被修改
