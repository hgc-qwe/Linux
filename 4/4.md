# 思考题

## 文件描述符 vs 文件路径

### 这一章的重点是使用文件描述符（fd） 进行I/O操作，而不是使用文件路径

#### 为什么通过open()获得文件描述符后，后续的read()、write()、lseek()都使用这个fd，而不再需要文件路径？

当调用open()成功后，内核会创建一个打开文件描述数据结构，其中记录了文件在磁盘的位置、当前的读写偏移量、访问模式等所有必要信息。后续的所有操作都通过文件描述符直接找到对应的内核数据结构，完全绕过了通过路径查找文件的繁琐过程。

## open() 的标志位（flags）

### open() 的第二个参数 flags 使用了位掩码来组合多个选项

#### 为什么这种设计（如 O_RDWR | O_CREAT | O_TRUNC）比设计成多个独立的参数更好？

使系统调用接口简洁、标志符组合灵活、扩展性好，可以随时添加新的标志位。

#### 当使用 O_CREAT 标志时，为什么必须提供第三个参数 mode？如果忘记设置，新建的文件权限可能会是什么？（可以结合 umask 来思考）

创建文件时必须指定起初始权限。如果忘记设置，编译器会使用栈上的随机值作为mode，导致文件的权限不可预测且很不安全。

## read() 和 write() 的“不保证”行为

### 书中强调，read() 和 write() 的返回值（实际读/写的字节数）可能小于请求的字节数。对于磁盘文件，这通常在什么情况下发生？对于其他类型的文件描述符（如管道、终端、套接字），这种情况是更常见还是更少见？为什么？

对于普通磁盘文件，在文件末尾时会发生。对于特殊文件，部分读写更常见。

- 数据可用性限制：从管道和网络套接字读取时，可能缓冲区只有50字节可用，即使请求100字节，也只能立即返回50字节
- 输出缓冲区限制：向终端和网络写入时，可能输出缓冲区已满，只接受部分数据
- 原子性考虑：对于数据流设备，部分传输是自然现象
