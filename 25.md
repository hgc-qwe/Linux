# 总结

## 进程终止的两种主要方式

### 正常终止

- 从 main()函数中 return
- 调用 exit() 函数
- 调用 _exit() 系统调用

### 异常终止

- 进程接收到特定的信号而终止
- 进程最后一个线程被取消

## 进程的终止状态

进程终止时，会向其父进程传递一个8位的终止状态

- 0 表示成功（EXIT_SUCCESS）
- 非0 表示失败（EXIT_FAILURE），不同的非零值通常用于表示不同的错误原因。这个值由程序员定义，可供脚本或父进程检查
- exit(status) 或 _exit(status) 中的 status 参数，只有低8位（0-255）对父进程有效

## exit()

### 库函数

- 按注册的逆序调用通过 atexit() 和 on_exit() 注册的退出处理函数。
- 刷新所有打开的 stdio 流缓冲区（将缓冲区数据写入文件）。
- 然后调用 _exit(status)。

## _exit()

### 系统调用

- 立即终止，不做任何用户空间清理
- 不调用退出处理函数。
- 不刷新 stdio 缓冲区。
- 直接向内核交出控制权，让内核进行进程终止的底层操作（关闭文件描述符、释放内存等）。

### 如果在子进程中调用 exit()，而父进程仍在运行，子进程可能会错误地刷新从父进程继承来的、本该由父进程刷新的 stdio 缓冲区，导致输出混乱。因此，在 fork() 后的子进程中，更推荐使用 _exit()

## 进程终止时的内核清理操作

- 关闭所有打开的文件描述符
- 释放进程持有的所有文件锁
- 释放进程使用的其他内核资源（如内存、信号量等）
- 将终止状态传递给父进程
- 如果父进程已经终止，本进程会成为“孤儿进程”，并由 init进程接管和回收

## 退出处理程序

### 注册函数

- `int atexit(void (*func)(void))`;
- `int on_exit(void (*func)(int, void*), void *arg)`; (可获取退出状态和参数，但可移植性差)

### 特性

- 可以注册多个处理函数。
- 执行顺序是 “后注册，先执行”（LIFO，栈结构）。
- 在 exit() 被调用时或 main() 函数 return 时自动执行。
- 不会被 _exit() 或信号杀死触发。
