# 总结

## 信号处理中的关键挑战

### 信号不排队带来的问题

- 核心问题：标准信号不排队，内核只维护“待处理”标志位
- 后果：短时间多次发生的相同信号可能被合并为一次
- 编程影响：必须假设信号可能多次发生，即使程序只触发一次

### 可重入性要求

- 定义：函数能在被中断后安全地再次调用
- 关键限制：信号处理器函数中只能调用异步信号安全的函数

## 信号处理器的高级终止方式

### 终止进程方式

- _exit()：立即终止，不执行清理
- kill(getpid(), sig)：发送信号终止自己
- abort()：产生 SIGABRT 和核心转储文件

### 非本地跳转

- setjmp()/longjmp()：不保存/恢复信号掩码
- sigsetjmp()/siglongjmp()：可控制信号掩码的保存与恢复

## 备选信号栈

为信号处理器提供独立的空间

```c
#include <signal.h>

stack_t ss;

// 分配备选栈
ss.ss_sp = malloc(SIGSTKSZ);
ss.ss_size = SIGSTKSZ;
ss.ss_flags = 0;

sigaltstack(&ss, NULL);  // 设置备选栈

// 在 sigaction 中指定使用备选栈
struct sigaction sa;
sa.sa_flags = SA_ONSTACK;
sigaction(SIGSEGV, &sa, NULL);
```

## 系统调用中断与重启

### 系统调用被信号中断

阻塞的系统调用（如 read(), sleep()）可能被信号中断，被中断时返回 -1，errno 设为 EINTR

### 手动重启

```c
int bytes_read;
while ((bytes_read = read(fd, buf, size)) == -1 && errno == EINTR) {
    // 被信号中断，继续重试
    continue;
}
```

### 自动重启

```c
struct sigaction sa;
sa.sa_flags = SA_RESTART;  // 关键标志
sigaction(SIGALRM, &sa, NULL);

// 现在 read() 等系统调用被 SIGALRM 中断时会自动重启
```
