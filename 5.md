# 思考题

## 原子操作的重要性

### 本章强调了多个操作的“原子性”，特别是文件创建（O_EXCL）和追加写入（O_APPEND）

#### 假设两个进程同时尝试创建同一个文件，为什么使用 open(path, O_CREAT | O_EXCL, ...) 比先检查文件是否存在再创建更安全？请描述可能发生的竞态条件

```c
if (access(path, F_OK) == -1) {
    // 在这段时间，另一个进程可能创建了该文件
    fd = open(path, O_CREAT | O_WRONLY, mode);
}
```

- p1检查文件，发现不存在
- p2检查文件，也发现不存在
- p1创建文件写入数据
- p2也创建文件，由于O_CREAT会覆盖已存在的文件，p1写入的数据被清空

#### 对于追加写入，为什么 O_APPEND 标志能保证多个进程同时写同一个日志文件时不发生数据覆盖，而使用 lseek(fd, 0, SEEK_END) 后再 write() 则不行？

```c
off_t offset = lseek(fd, 0, SEEK_END);

write(fd, bufA, lenA);
write(fd, bufB, lenB);
```

- A获取末尾位置，假设是100
- B获取末尾位置，也是100
- A在位置100写入50字节数据
- B在位置100写入30字节数据，进程B的数据覆盖了进程A的数据

```c
fd = open(path, O_WRONLY | O_APPEND); // 每次write前，内核自动将文件偏移量设置为文件末尾
write(fd, buf, len);
```

## 文件空洞与稀疏文件

### 书中提到，可以使用 lseek() 跳过一些字节再写入，从而在文件中创建“空洞”

#### 这种包含空洞的文件在磁盘上实际占用多少空间？例如，创建一个1GB大小的空洞文件，实际占用磁盘空间是多少？

小于1GB。文件系统只为实际写入数据的块分配磁盘空间，空洞部分只记录在元数据中，指向特殊的全零块根本不分配物理块

#### 为什么像数据库这样的应用可能会受益于稀疏文件？

- 数据库可以预先保留一个大文件，但实际只占用很少的空间，随着数据增长，物理空间逐渐分配
- 连续的虚拟地址空间可以减少碎片化，提高顺序访问性能
- 创建大型数据库文件几乎瞬间完成，因为不需要实际写入全零数据

## fcntl() 的灵活性

### fcntl() 被称为“文件控制多功能瑞士军刀”

#### 它主要提供了哪三大类功能？（提示：文件描述符标志、文件状态标志、记录锁）

- 复制文件描述符
- 获取/设置文件描述符标志
- 获取/设置文件状态标志
- 管理文件锁
